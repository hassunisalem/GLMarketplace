{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _ssrWindow = require(\"ssr-window\");\n\nvar _dom = _interopRequireDefault(require(\"../../utils/dom\"));\n\nvar _utils = require(\"../../utils/utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/* eslint-disable consistent-return */\n\n\nfunction isEventSupported() {\n  var document = (0, _ssrWindow.getDocument)();\n  var eventName = 'onwheel';\n  var isSupported = (eventName in document);\n\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  if (!isSupported && document.implementation && document.implementation.hasFeature && // always returns true in newer browsers as per the standard.\n  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n  document.implementation.hasFeature('', '') !== true) {\n    // This is the only way to test support for the `wheel` event in IE9+.\n    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\n  }\n\n  return isSupported;\n}\n\nvar Mousewheel = {\n  lastScrollTime: (0, _utils.now)(),\n  lastEventBeforeSnap: undefined,\n  recentWheelEvents: [],\n  event: function event() {\n    var window = (0, _ssrWindow.getWindow)();\n    if (window.navigator.userAgent.indexOf('firefox') > -1) return 'DOMMouseScroll';\n    return isEventSupported() ? 'wheel' : 'mousewheel';\n  },\n  normalize: function normalize(e) {\n    // Reasonable defaults\n    var PIXEL_STEP = 10;\n    var LINE_HEIGHT = 40;\n    var PAGE_HEIGHT = 800;\n    var sX = 0;\n    var sY = 0; // spinX, spinY\n\n    var pX = 0;\n    var pY = 0; // pixelX, pixelY\n    // Legacy\n\n    if ('detail' in e) {\n      sY = e.detail;\n    }\n\n    if ('wheelDelta' in e) {\n      sY = -e.wheelDelta / 120;\n    }\n\n    if ('wheelDeltaY' in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n\n    if ('wheelDeltaX' in e) {\n      sX = -e.wheelDeltaX / 120;\n    } // side scrolling on FF with DOMMouseScroll\n\n\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n\n    if ('deltaY' in e) {\n      pY = e.deltaY;\n    }\n\n    if ('deltaX' in e) {\n      pX = e.deltaX;\n    }\n\n    if (e.shiftKey && !pX) {\n      // if user scrolls with shift he wants horizontal scroll\n      pX = pY;\n      pY = 0;\n    }\n\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) {\n        // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else {\n        // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    } // Fall-back if spin cannot be determined\n\n\n    if (pX && !sX) {\n      sX = pX < 1 ? -1 : 1;\n    }\n\n    if (pY && !sY) {\n      sY = pY < 1 ? -1 : 1;\n    }\n\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY\n    };\n  },\n  handleMouseEnter: function handleMouseEnter() {\n    var swiper = this;\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = true;\n  },\n  handleMouseLeave: function handleMouseLeave() {\n    var swiper = this;\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = false;\n  },\n  handle: function handle(event) {\n    var e = event;\n    var disableParentSwiper = true;\n    var swiper = this;\n    if (!swiper.enabled) return;\n    var params = swiper.params.mousewheel;\n\n    if (swiper.params.cssMode) {\n      e.preventDefault();\n    }\n\n    var target = swiper.$el;\n\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      target = (0, _dom.default)(swiper.params.mousewheel.eventsTarget);\n    }\n\n    if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n\n    var delta = 0;\n    var rtlFactor = swiper.rtlTranslate ? -1 : 1;\n    var data = Mousewheel.normalize(e);\n\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\n    } else {\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n\n    if (delta === 0) return true;\n    if (params.invert) delta = -delta; // Get the scroll positions\n\n    var positions = swiper.getTranslate() + delta * params.sensitivity;\n    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate(); // When loop is true:\n    //     the disableParentSwiper will be true.\n    // When loop is false:\n    //     if the scroll positions is not on edge,\n    //     then the disableParentSwiper will be true.\n    //     if the scroll on edge positions,\n    //     then the disableParentSwiper will be false.\n\n    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n\n    if (!swiper.params.freeMode) {\n      // Register the new event in a variable which stores the relevant data\n      var newEvent = {\n        time: (0, _utils.now)(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n        raw: event\n      }; // Keep the most recent events\n\n      var recentWheelEvents = swiper.mousewheel.recentWheelEvents;\n\n      if (recentWheelEvents.length >= 2) {\n        recentWheelEvents.shift(); // only store the last N events\n      }\n\n      var prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n      recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:\n      //   If direction has changed or\n      //   if the scroll is quicker than the previous one:\n      //     Animate the slider.\n      // Else (this is the first time the wheel is moved):\n      //     Animate the slider.\n\n      if (prevEvent) {\n        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n          swiper.mousewheel.animateSlider(newEvent);\n        }\n      } else {\n        swiper.mousewheel.animateSlider(newEvent);\n      } // If it's time to release the scroll:\n      //   Return now so you don't hit the preventDefault.\n\n\n      if (swiper.mousewheel.releaseScroll(newEvent)) {\n        return true;\n      }\n    } else {\n      // Freemode or scrollContainer:\n      // If we recently snapped after a momentum scroll, then ignore wheel events\n      // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n      // or if it's a new scroll (larger delta or inverse sign as last event before\n      // an end-of-momentum snap).\n      var _newEvent = {\n        time: (0, _utils.now)(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta)\n      };\n      var lastEventBeforeSnap = swiper.mousewheel.lastEventBeforeSnap;\n      var ignoreWheelEvents = lastEventBeforeSnap && _newEvent.time < lastEventBeforeSnap.time + 500 && _newEvent.delta <= lastEventBeforeSnap.delta && _newEvent.direction === lastEventBeforeSnap.direction;\n\n      if (!ignoreWheelEvents) {\n        swiper.mousewheel.lastEventBeforeSnap = undefined;\n\n        if (swiper.params.loop) {\n          swiper.loopFix();\n        }\n\n        var position = swiper.getTranslate() + delta * params.sensitivity;\n        var wasBeginning = swiper.isBeginning;\n        var wasEnd = swiper.isEnd;\n        if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n        swiper.setTransition(0);\n        swiper.setTranslate(position);\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n\n        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n          swiper.updateSlidesClasses();\n        }\n\n        if (swiper.params.freeModeSticky) {\n          // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n          // the end of a momentum scroll by storing recent (N=15?) wheel events.\n          // 1. do all N events have decreasing or same (absolute value) delta?\n          // 2. did all N events arrive in the last M (M=500?) msecs?\n          // 3. does the earliest event have an (absolute value) delta that's\n          //    at least P (P=1?) larger than the most recent event's delta?\n          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n          // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n          // Snap immediately and ignore remaining wheel events in this scroll.\n          // See comment above for \"remaining wheel events in this scroll\" determination.\n          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n          clearTimeout(swiper.mousewheel.timeout);\n          swiper.mousewheel.timeout = undefined;\n          var _recentWheelEvents = swiper.mousewheel.recentWheelEvents;\n\n          if (_recentWheelEvents.length >= 15) {\n            _recentWheelEvents.shift(); // only store the last N events\n\n          }\n\n          var _prevEvent = _recentWheelEvents.length ? _recentWheelEvents[_recentWheelEvents.length - 1] : undefined;\n\n          var firstEvent = _recentWheelEvents[0];\n\n          _recentWheelEvents.push(_newEvent);\n\n          if (_prevEvent && (_newEvent.delta > _prevEvent.delta || _newEvent.direction !== _prevEvent.direction)) {\n            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n            _recentWheelEvents.splice(0);\n          } else if (_recentWheelEvents.length >= 15 && _newEvent.time - firstEvent.time < 500 && firstEvent.delta - _newEvent.delta >= 1 && _newEvent.delta <= 6) {\n            // We're at the end of the deceleration of a momentum scroll, so there's no need\n            // to wait for more events. Snap ASAP on the next tick.\n            // Also, because there's some remaining momentum we'll bias the snap in the\n            // direction of the ongoing scroll because it's better UX for the scroll to snap\n            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n            // if it's already scrolled more than 20% in the current direction, keep going.\n            var snapToThreshold = delta > 0 ? 0.8 : 0.2;\n            swiper.mousewheel.lastEventBeforeSnap = _newEvent;\n\n            _recentWheelEvents.splice(0);\n\n            swiper.mousewheel.timeout = (0, _utils.nextTick)(function () {\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 0); // no delay; move on next tick\n          }\n\n          if (!swiper.mousewheel.timeout) {\n            // if we get here, then we haven't detected the end of a momentum scroll, so\n            // we'll consider a scroll \"complete\" when there haven't been any wheel events\n            // for 500ms.\n            swiper.mousewheel.timeout = (0, _utils.nextTick)(function () {\n              var snapToThreshold = 0.5;\n              swiper.mousewheel.lastEventBeforeSnap = _newEvent;\n\n              _recentWheelEvents.splice(0);\n\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 500);\n          }\n        } // Emit event\n\n\n        if (!ignoreWheelEvents) swiper.emit('scroll', e); // Stop autoplay\n\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); // Return page scroll on edge positions\n\n        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n      }\n    }\n\n    if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n    return false;\n  },\n  animateSlider: function animateSlider(newEvent) {\n    var swiper = this;\n    var window = (0, _ssrWindow.getWindow)();\n\n    if (this.params.mousewheel.thresholdDelta && newEvent.delta < this.params.mousewheel.thresholdDelta) {\n      // Prevent if delta of wheel scroll delta is below configured threshold\n      return false;\n    }\n\n    if (this.params.mousewheel.thresholdTime && (0, _utils.now)() - swiper.mousewheel.lastScrollTime < this.params.mousewheel.thresholdTime) {\n      // Prevent if time between scrolls is below configured threshold\n      return false;\n    } // If the movement is NOT big enough and\n    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n    //   Don't go any further (avoid insignificant scroll movement).\n\n\n    if (newEvent.delta >= 6 && (0, _utils.now)() - swiper.mousewheel.lastScrollTime < 60) {\n      // Return false as a default\n      return true;\n    } // If user is scrolling towards the end:\n    //   If the slider hasn't hit the latest slide or\n    //   if the slider is a loop and\n    //   if the slider isn't moving right now:\n    //     Go to next slide and\n    //     emit a scroll event.\n    // Else (the user is scrolling towards the beginning) and\n    // if the slider hasn't hit the first slide or\n    // if the slider is a loop and\n    // if the slider isn't moving right now:\n    //   Go to prev slide and\n    //   emit a scroll event.\n\n\n    if (newEvent.direction < 0) {\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n        swiper.slideNext();\n        swiper.emit('scroll', newEvent.raw);\n      }\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n      swiper.slidePrev();\n      swiper.emit('scroll', newEvent.raw);\n    } // If you got here is because an animation has been triggered so store the current time\n\n\n    swiper.mousewheel.lastScrollTime = new window.Date().getTime(); // Return false as a default\n\n    return false;\n  },\n  releaseScroll: function releaseScroll(newEvent) {\n    var swiper = this;\n    var params = swiper.params.mousewheel;\n\n    if (newEvent.direction < 0) {\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n        // Return true to animate scroll on edges\n        return true;\n      }\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n      // Return true to animate scroll on edges\n      return true;\n    }\n\n    return false;\n  },\n  enable: function enable() {\n    var swiper = this;\n    var event = Mousewheel.event();\n\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.removeEventListener(event, swiper.mousewheel.handle);\n      return true;\n    }\n\n    if (!event) return false;\n    if (swiper.mousewheel.enabled) return false;\n    var target = swiper.$el;\n\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      target = (0, _dom.default)(swiper.params.mousewheel.eventsTarget);\n    }\n\n    target.on('mouseenter', swiper.mousewheel.handleMouseEnter);\n    target.on('mouseleave', swiper.mousewheel.handleMouseLeave);\n    target.on(event, swiper.mousewheel.handle);\n    swiper.mousewheel.enabled = true;\n    return true;\n  },\n  disable: function disable() {\n    var swiper = this;\n    var event = Mousewheel.event();\n\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.addEventListener(event, swiper.mousewheel.handle);\n      return true;\n    }\n\n    if (!event) return false;\n    if (!swiper.mousewheel.enabled) return false;\n    var target = swiper.$el;\n\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      target = (0, _dom.default)(swiper.params.mousewheel.eventsTarget);\n    }\n\n    target.off(event, swiper.mousewheel.handle);\n    swiper.mousewheel.enabled = false;\n    return true;\n  }\n};\nvar _default = {\n  name: 'mousewheel',\n  params: {\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarget: 'container',\n      thresholdDelta: null,\n      thresholdTime: null\n    }\n  },\n  create: function create() {\n    var swiper = this;\n    (0, _utils.bindModuleMethods)(swiper, {\n      mousewheel: {\n        enabled: false,\n        lastScrollTime: (0, _utils.now)(),\n        lastEventBeforeSnap: undefined,\n        recentWheelEvents: [],\n        enable: Mousewheel.enable,\n        disable: Mousewheel.disable,\n        handle: Mousewheel.handle,\n        handleMouseEnter: Mousewheel.handleMouseEnter,\n        handleMouseLeave: Mousewheel.handleMouseLeave,\n        animateSlider: Mousewheel.animateSlider,\n        releaseScroll: Mousewheel.releaseScroll\n      }\n    });\n  },\n  on: {\n    init: function init(swiper) {\n      if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n        swiper.mousewheel.disable();\n      }\n\n      if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();\n    },\n    destroy: function destroy(swiper) {\n      if (swiper.params.cssMode) {\n        swiper.mousewheel.enable();\n      }\n\n      if (swiper.mousewheel.enabled) swiper.mousewheel.disable();\n    }\n  }\n};\nexports.default = _default;","map":{"version":3,"sources":["C:/Users/hasss/Documents/ReactProjects/GLMarketplace/marketplace/node_modules/swiper/cjs/components/mousewheel/mousewheel.js"],"names":["exports","__esModule","default","_ssrWindow","require","_dom","_interopRequireDefault","_utils","obj","isEventSupported","document","getDocument","eventName","isSupported","element","createElement","setAttribute","implementation","hasFeature","Mousewheel","lastScrollTime","now","lastEventBeforeSnap","undefined","recentWheelEvents","event","window","getWindow","navigator","userAgent","indexOf","normalize","e","PIXEL_STEP","LINE_HEIGHT","PAGE_HEIGHT","sX","sY","pX","pY","detail","wheelDelta","wheelDeltaY","wheelDeltaX","axis","HORIZONTAL_AXIS","deltaY","deltaX","shiftKey","deltaMode","spinX","spinY","pixelX","pixelY","handleMouseEnter","swiper","enabled","mouseEntered","handleMouseLeave","handle","disableParentSwiper","params","mousewheel","cssMode","preventDefault","target","$el","eventsTarget","contains","releaseOnEdges","originalEvent","delta","rtlFactor","rtlTranslate","data","forceToAxis","isHorizontal","Math","abs","invert","positions","getTranslate","sensitivity","minTranslate","maxTranslate","loop","nested","stopPropagation","freeMode","newEvent","time","direction","sign","raw","length","shift","prevEvent","push","animateSlider","releaseScroll","_newEvent","ignoreWheelEvents","loopFix","position","wasBeginning","isBeginning","wasEnd","isEnd","setTransition","setTranslate","updateProgress","updateActiveIndex","updateSlidesClasses","freeModeSticky","clearTimeout","timeout","_recentWheelEvents","_prevEvent","firstEvent","splice","snapToThreshold","nextTick","slideToClosest","speed","emit","autoplay","autoplayDisableOnInteraction","stop","returnValue","thresholdDelta","thresholdTime","animating","slideNext","slidePrev","Date","getTime","enable","wrapperEl","removeEventListener","on","disable","addEventListener","off","_default","name","create","bindModuleMethods","init","destroy"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _ssrWindow = require(\"ssr-window\");\n\nvar _dom = _interopRequireDefault(require(\"../../utils/dom\"));\n\nvar _utils = require(\"../../utils/utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint-disable consistent-return */\nfunction isEventSupported() {\n  var document = (0, _ssrWindow.getDocument)();\n  var eventName = 'onwheel';\n  var isSupported = (eventName in document);\n\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  if (!isSupported && document.implementation && document.implementation.hasFeature && // always returns true in newer browsers as per the standard.\n  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n  document.implementation.hasFeature('', '') !== true) {\n    // This is the only way to test support for the `wheel` event in IE9+.\n    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\n  }\n\n  return isSupported;\n}\n\nvar Mousewheel = {\n  lastScrollTime: (0, _utils.now)(),\n  lastEventBeforeSnap: undefined,\n  recentWheelEvents: [],\n  event: function event() {\n    var window = (0, _ssrWindow.getWindow)();\n    if (window.navigator.userAgent.indexOf('firefox') > -1) return 'DOMMouseScroll';\n    return isEventSupported() ? 'wheel' : 'mousewheel';\n  },\n  normalize: function normalize(e) {\n    // Reasonable defaults\n    var PIXEL_STEP = 10;\n    var LINE_HEIGHT = 40;\n    var PAGE_HEIGHT = 800;\n    var sX = 0;\n    var sY = 0; // spinX, spinY\n\n    var pX = 0;\n    var pY = 0; // pixelX, pixelY\n    // Legacy\n\n    if ('detail' in e) {\n      sY = e.detail;\n    }\n\n    if ('wheelDelta' in e) {\n      sY = -e.wheelDelta / 120;\n    }\n\n    if ('wheelDeltaY' in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n\n    if ('wheelDeltaX' in e) {\n      sX = -e.wheelDeltaX / 120;\n    } // side scrolling on FF with DOMMouseScroll\n\n\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n\n    if ('deltaY' in e) {\n      pY = e.deltaY;\n    }\n\n    if ('deltaX' in e) {\n      pX = e.deltaX;\n    }\n\n    if (e.shiftKey && !pX) {\n      // if user scrolls with shift he wants horizontal scroll\n      pX = pY;\n      pY = 0;\n    }\n\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) {\n        // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else {\n        // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    } // Fall-back if spin cannot be determined\n\n\n    if (pX && !sX) {\n      sX = pX < 1 ? -1 : 1;\n    }\n\n    if (pY && !sY) {\n      sY = pY < 1 ? -1 : 1;\n    }\n\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY\n    };\n  },\n  handleMouseEnter: function handleMouseEnter() {\n    var swiper = this;\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = true;\n  },\n  handleMouseLeave: function handleMouseLeave() {\n    var swiper = this;\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = false;\n  },\n  handle: function handle(event) {\n    var e = event;\n    var disableParentSwiper = true;\n    var swiper = this;\n    if (!swiper.enabled) return;\n    var params = swiper.params.mousewheel;\n\n    if (swiper.params.cssMode) {\n      e.preventDefault();\n    }\n\n    var target = swiper.$el;\n\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      target = (0, _dom.default)(swiper.params.mousewheel.eventsTarget);\n    }\n\n    if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n\n    var delta = 0;\n    var rtlFactor = swiper.rtlTranslate ? -1 : 1;\n    var data = Mousewheel.normalize(e);\n\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\n    } else {\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n\n    if (delta === 0) return true;\n    if (params.invert) delta = -delta; // Get the scroll positions\n\n    var positions = swiper.getTranslate() + delta * params.sensitivity;\n    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate(); // When loop is true:\n    //     the disableParentSwiper will be true.\n    // When loop is false:\n    //     if the scroll positions is not on edge,\n    //     then the disableParentSwiper will be true.\n    //     if the scroll on edge positions,\n    //     then the disableParentSwiper will be false.\n\n    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n\n    if (!swiper.params.freeMode) {\n      // Register the new event in a variable which stores the relevant data\n      var newEvent = {\n        time: (0, _utils.now)(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n        raw: event\n      }; // Keep the most recent events\n\n      var recentWheelEvents = swiper.mousewheel.recentWheelEvents;\n\n      if (recentWheelEvents.length >= 2) {\n        recentWheelEvents.shift(); // only store the last N events\n      }\n\n      var prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n      recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:\n      //   If direction has changed or\n      //   if the scroll is quicker than the previous one:\n      //     Animate the slider.\n      // Else (this is the first time the wheel is moved):\n      //     Animate the slider.\n\n      if (prevEvent) {\n        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n          swiper.mousewheel.animateSlider(newEvent);\n        }\n      } else {\n        swiper.mousewheel.animateSlider(newEvent);\n      } // If it's time to release the scroll:\n      //   Return now so you don't hit the preventDefault.\n\n\n      if (swiper.mousewheel.releaseScroll(newEvent)) {\n        return true;\n      }\n    } else {\n      // Freemode or scrollContainer:\n      // If we recently snapped after a momentum scroll, then ignore wheel events\n      // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n      // or if it's a new scroll (larger delta or inverse sign as last event before\n      // an end-of-momentum snap).\n      var _newEvent = {\n        time: (0, _utils.now)(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta)\n      };\n      var lastEventBeforeSnap = swiper.mousewheel.lastEventBeforeSnap;\n      var ignoreWheelEvents = lastEventBeforeSnap && _newEvent.time < lastEventBeforeSnap.time + 500 && _newEvent.delta <= lastEventBeforeSnap.delta && _newEvent.direction === lastEventBeforeSnap.direction;\n\n      if (!ignoreWheelEvents) {\n        swiper.mousewheel.lastEventBeforeSnap = undefined;\n\n        if (swiper.params.loop) {\n          swiper.loopFix();\n        }\n\n        var position = swiper.getTranslate() + delta * params.sensitivity;\n        var wasBeginning = swiper.isBeginning;\n        var wasEnd = swiper.isEnd;\n        if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n        swiper.setTransition(0);\n        swiper.setTranslate(position);\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n\n        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n          swiper.updateSlidesClasses();\n        }\n\n        if (swiper.params.freeModeSticky) {\n          // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n          // the end of a momentum scroll by storing recent (N=15?) wheel events.\n          // 1. do all N events have decreasing or same (absolute value) delta?\n          // 2. did all N events arrive in the last M (M=500?) msecs?\n          // 3. does the earliest event have an (absolute value) delta that's\n          //    at least P (P=1?) larger than the most recent event's delta?\n          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n          // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n          // Snap immediately and ignore remaining wheel events in this scroll.\n          // See comment above for \"remaining wheel events in this scroll\" determination.\n          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n          clearTimeout(swiper.mousewheel.timeout);\n          swiper.mousewheel.timeout = undefined;\n          var _recentWheelEvents = swiper.mousewheel.recentWheelEvents;\n\n          if (_recentWheelEvents.length >= 15) {\n            _recentWheelEvents.shift(); // only store the last N events\n\n          }\n\n          var _prevEvent = _recentWheelEvents.length ? _recentWheelEvents[_recentWheelEvents.length - 1] : undefined;\n\n          var firstEvent = _recentWheelEvents[0];\n\n          _recentWheelEvents.push(_newEvent);\n\n          if (_prevEvent && (_newEvent.delta > _prevEvent.delta || _newEvent.direction !== _prevEvent.direction)) {\n            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n            _recentWheelEvents.splice(0);\n          } else if (_recentWheelEvents.length >= 15 && _newEvent.time - firstEvent.time < 500 && firstEvent.delta - _newEvent.delta >= 1 && _newEvent.delta <= 6) {\n            // We're at the end of the deceleration of a momentum scroll, so there's no need\n            // to wait for more events. Snap ASAP on the next tick.\n            // Also, because there's some remaining momentum we'll bias the snap in the\n            // direction of the ongoing scroll because it's better UX for the scroll to snap\n            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n            // if it's already scrolled more than 20% in the current direction, keep going.\n            var snapToThreshold = delta > 0 ? 0.8 : 0.2;\n            swiper.mousewheel.lastEventBeforeSnap = _newEvent;\n\n            _recentWheelEvents.splice(0);\n\n            swiper.mousewheel.timeout = (0, _utils.nextTick)(function () {\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 0); // no delay; move on next tick\n          }\n\n          if (!swiper.mousewheel.timeout) {\n            // if we get here, then we haven't detected the end of a momentum scroll, so\n            // we'll consider a scroll \"complete\" when there haven't been any wheel events\n            // for 500ms.\n            swiper.mousewheel.timeout = (0, _utils.nextTick)(function () {\n              var snapToThreshold = 0.5;\n              swiper.mousewheel.lastEventBeforeSnap = _newEvent;\n\n              _recentWheelEvents.splice(0);\n\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 500);\n          }\n        } // Emit event\n\n\n        if (!ignoreWheelEvents) swiper.emit('scroll', e); // Stop autoplay\n\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); // Return page scroll on edge positions\n\n        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n      }\n    }\n\n    if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n    return false;\n  },\n  animateSlider: function animateSlider(newEvent) {\n    var swiper = this;\n    var window = (0, _ssrWindow.getWindow)();\n\n    if (this.params.mousewheel.thresholdDelta && newEvent.delta < this.params.mousewheel.thresholdDelta) {\n      // Prevent if delta of wheel scroll delta is below configured threshold\n      return false;\n    }\n\n    if (this.params.mousewheel.thresholdTime && (0, _utils.now)() - swiper.mousewheel.lastScrollTime < this.params.mousewheel.thresholdTime) {\n      // Prevent if time between scrolls is below configured threshold\n      return false;\n    } // If the movement is NOT big enough and\n    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n    //   Don't go any further (avoid insignificant scroll movement).\n\n\n    if (newEvent.delta >= 6 && (0, _utils.now)() - swiper.mousewheel.lastScrollTime < 60) {\n      // Return false as a default\n      return true;\n    } // If user is scrolling towards the end:\n    //   If the slider hasn't hit the latest slide or\n    //   if the slider is a loop and\n    //   if the slider isn't moving right now:\n    //     Go to next slide and\n    //     emit a scroll event.\n    // Else (the user is scrolling towards the beginning) and\n    // if the slider hasn't hit the first slide or\n    // if the slider is a loop and\n    // if the slider isn't moving right now:\n    //   Go to prev slide and\n    //   emit a scroll event.\n\n\n    if (newEvent.direction < 0) {\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n        swiper.slideNext();\n        swiper.emit('scroll', newEvent.raw);\n      }\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n      swiper.slidePrev();\n      swiper.emit('scroll', newEvent.raw);\n    } // If you got here is because an animation has been triggered so store the current time\n\n\n    swiper.mousewheel.lastScrollTime = new window.Date().getTime(); // Return false as a default\n\n    return false;\n  },\n  releaseScroll: function releaseScroll(newEvent) {\n    var swiper = this;\n    var params = swiper.params.mousewheel;\n\n    if (newEvent.direction < 0) {\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n        // Return true to animate scroll on edges\n        return true;\n      }\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n      // Return true to animate scroll on edges\n      return true;\n    }\n\n    return false;\n  },\n  enable: function enable() {\n    var swiper = this;\n    var event = Mousewheel.event();\n\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.removeEventListener(event, swiper.mousewheel.handle);\n      return true;\n    }\n\n    if (!event) return false;\n    if (swiper.mousewheel.enabled) return false;\n    var target = swiper.$el;\n\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      target = (0, _dom.default)(swiper.params.mousewheel.eventsTarget);\n    }\n\n    target.on('mouseenter', swiper.mousewheel.handleMouseEnter);\n    target.on('mouseleave', swiper.mousewheel.handleMouseLeave);\n    target.on(event, swiper.mousewheel.handle);\n    swiper.mousewheel.enabled = true;\n    return true;\n  },\n  disable: function disable() {\n    var swiper = this;\n    var event = Mousewheel.event();\n\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.addEventListener(event, swiper.mousewheel.handle);\n      return true;\n    }\n\n    if (!event) return false;\n    if (!swiper.mousewheel.enabled) return false;\n    var target = swiper.$el;\n\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      target = (0, _dom.default)(swiper.params.mousewheel.eventsTarget);\n    }\n\n    target.off(event, swiper.mousewheel.handle);\n    swiper.mousewheel.enabled = false;\n    return true;\n  }\n};\nvar _default = {\n  name: 'mousewheel',\n  params: {\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarget: 'container',\n      thresholdDelta: null,\n      thresholdTime: null\n    }\n  },\n  create: function create() {\n    var swiper = this;\n    (0, _utils.bindModuleMethods)(swiper, {\n      mousewheel: {\n        enabled: false,\n        lastScrollTime: (0, _utils.now)(),\n        lastEventBeforeSnap: undefined,\n        recentWheelEvents: [],\n        enable: Mousewheel.enable,\n        disable: Mousewheel.disable,\n        handle: Mousewheel.handle,\n        handleMouseEnter: Mousewheel.handleMouseEnter,\n        handleMouseLeave: Mousewheel.handleMouseLeave,\n        animateSlider: Mousewheel.animateSlider,\n        releaseScroll: Mousewheel.releaseScroll\n      }\n    });\n  },\n  on: {\n    init: function init(swiper) {\n      if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n        swiper.mousewheel.disable();\n      }\n\n      if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();\n    },\n    destroy: function destroy(swiper) {\n      if (swiper.params.cssMode) {\n        swiper.mousewheel.enable();\n      }\n\n      if (swiper.mousewheel.enabled) swiper.mousewheel.disable();\n    }\n  }\n};\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}