{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = onTouchEnd;\n\nvar _utils = require(\"../../../utils/utils\");\n\nfunction onTouchEnd(event) {\n  var swiper = this;\n  var data = swiper.touchEventsData;\n  var params = swiper.params,\n      touches = swiper.touches,\n      rtl = swiper.rtlTranslate,\n      $wrapperEl = swiper.$wrapperEl,\n      slidesGrid = swiper.slidesGrid,\n      snapGrid = swiper.snapGrid,\n      enabled = swiper.enabled;\n  if (!enabled) return;\n  var e = event;\n  if (e.originalEvent) e = e.originalEvent;\n\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchEnd', e);\n  }\n\n  data.allowTouchCallbacks = false;\n\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  } // Return Grab Cursor\n\n\n  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n    swiper.setGrabCursor(false);\n  } // Time diff\n\n\n  var touchEndTime = (0, _utils.now)();\n  var timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click\n\n  if (swiper.allowClick) {\n    swiper.updateClickedSlide(e);\n    swiper.emit('tap click', e);\n\n    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n      swiper.emit('doubleTap doubleClick', e);\n    }\n  }\n\n  data.lastClickTime = (0, _utils.now)();\n  (0, _utils.nextTick)(function () {\n    if (!swiper.destroyed) swiper.allowClick = true;\n  });\n\n  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n  var currentPos;\n\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n\n  if (params.cssMode) {\n    return;\n  }\n\n  if (params.freeMode) {\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n\n      return;\n    }\n\n    if (params.freeModeMomentum) {\n      if (data.velocities.length > 1) {\n        var lastMoveEvent = data.velocities.pop();\n        var velocityEvent = data.velocities.pop();\n        var distance = lastMoveEvent.position - velocityEvent.position;\n        var time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n\n        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {\n          swiper.velocity = 0;\n        } // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n\n\n        if (time > 150 || (0, _utils.now)() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n\n      swiper.velocity *= params.freeModeMomentumVelocityRatio;\n      data.velocities.length = 0;\n      var momentumDuration = 1000 * params.freeModeMomentumRatio;\n      var momentumDistance = swiper.velocity * momentumDuration;\n      var newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n      var doBounce = false;\n      var afterBouncePosition;\n      var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;\n      var needsLoopFix;\n\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeModeSticky) {\n        var nextSlide;\n\n        for (var j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n\n        newPosition = -newPosition;\n      }\n\n      if (needsLoopFix) {\n        swiper.once('transitionEnd', function () {\n          swiper.loopFix();\n        });\n      } // Fix duration\n\n\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n\n        if (params.freeModeSticky) {\n          // If freeModeSticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeModeSticky) {\n        swiper.slideToClosest();\n        return;\n      }\n\n      if (params.freeModeMomentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        $wrapperEl.transitionEnd(function () {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          swiper.emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          setTimeout(function () {\n            swiper.setTranslate(afterBouncePosition);\n            $wrapperEl.transitionEnd(function () {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n\n        if (!swiper.animating) {\n          swiper.animating = true;\n          $wrapperEl.transitionEnd(function () {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.emit('_freeModeNoMomentumRelease');\n        swiper.updateProgress(newPosition);\n      }\n\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeModeSticky) {\n      swiper.slideToClosest();\n      return;\n    } else if (params.freeMode) {\n      swiper.emit('_freeModeNoMomentumRelease');\n    }\n\n    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n\n    return;\n  } // Find current slide\n\n\n  var stopIndex = 0;\n  var groupSize = swiper.slidesSizesGrid[0];\n\n  for (var i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n    var _increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\n    if (typeof slidesGrid[i + _increment] !== 'undefined') {\n      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + _increment]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + _increment] - slidesGrid[i];\n      }\n    } else if (currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  } // Find current slide size\n\n\n  var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n  var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\n  if (timeDiff > params.longSwipesMs) {\n    // Long touches\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (swiper.swipeDirection === 'next') {\n      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);\n    }\n\n    if (swiper.swipeDirection === 'prev') {\n      if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);\n    }\n  } else {\n    // Short swipes\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n\n    if (!isNavButtonTarget) {\n      if (swiper.swipeDirection === 'next') {\n        swiper.slideTo(stopIndex + increment);\n      }\n\n      if (swiper.swipeDirection === 'prev') {\n        swiper.slideTo(stopIndex);\n      }\n    } else if (e.target === swiper.navigation.nextEl) {\n      swiper.slideTo(stopIndex + increment);\n    } else {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}","map":{"version":3,"sources":["C:/Users/hasss/Documents/ReactProjects/GLMarketplace/marketplace/node_modules/swiper/cjs/components/core/events/onTouchEnd.js"],"names":["exports","__esModule","default","onTouchEnd","_utils","require","event","swiper","data","touchEventsData","params","touches","rtl","rtlTranslate","$wrapperEl","slidesGrid","snapGrid","enabled","e","originalEvent","allowTouchCallbacks","emit","isTouched","isMoved","grabCursor","setGrabCursor","startMoving","allowSlideNext","allowSlidePrev","touchEndTime","now","timeDiff","touchStartTime","allowClick","updateClickedSlide","lastClickTime","nextTick","destroyed","swipeDirection","diff","currentTranslate","startTranslate","currentPos","followFinger","translate","cssMode","freeMode","minTranslate","slideTo","activeIndex","maxTranslate","slides","length","freeModeMomentum","velocities","lastMoveEvent","pop","velocityEvent","distance","position","time","velocity","Math","abs","freeModeMinimumVelocity","freeModeMomentumVelocityRatio","momentumDuration","freeModeMomentumRatio","momentumDistance","newPosition","doBounce","afterBouncePosition","bounceAmount","freeModeMomentumBounceRatio","needsLoopFix","freeModeMomentumBounce","allowMomentumBounce","loop","centeredSlides","freeModeSticky","nextSlide","j","once","loopFix","moveDistance","currentSlideSize","slidesSizesGrid","speed","slideToClosest","updateProgress","setTransition","setTranslate","transitionStart","animating","transitionEnd","setTimeout","updateActiveIndex","updateSlidesClasses","longSwipesMs","stopIndex","groupSize","i","slidesPerGroupSkip","slidesPerGroup","_increment","ratio","increment","longSwipes","longSwipesRatio","shortSwipes","isNavButtonTarget","navigation","target","nextEl","prevEl"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = onTouchEnd;\n\nvar _utils = require(\"../../../utils/utils\");\n\nfunction onTouchEnd(event) {\n  var swiper = this;\n  var data = swiper.touchEventsData;\n  var params = swiper.params,\n      touches = swiper.touches,\n      rtl = swiper.rtlTranslate,\n      $wrapperEl = swiper.$wrapperEl,\n      slidesGrid = swiper.slidesGrid,\n      snapGrid = swiper.snapGrid,\n      enabled = swiper.enabled;\n  if (!enabled) return;\n  var e = event;\n  if (e.originalEvent) e = e.originalEvent;\n\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchEnd', e);\n  }\n\n  data.allowTouchCallbacks = false;\n\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  } // Return Grab Cursor\n\n\n  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n    swiper.setGrabCursor(false);\n  } // Time diff\n\n\n  var touchEndTime = (0, _utils.now)();\n  var timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click\n\n  if (swiper.allowClick) {\n    swiper.updateClickedSlide(e);\n    swiper.emit('tap click', e);\n\n    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n      swiper.emit('doubleTap doubleClick', e);\n    }\n  }\n\n  data.lastClickTime = (0, _utils.now)();\n  (0, _utils.nextTick)(function () {\n    if (!swiper.destroyed) swiper.allowClick = true;\n  });\n\n  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n  var currentPos;\n\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n\n  if (params.cssMode) {\n    return;\n  }\n\n  if (params.freeMode) {\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n\n      return;\n    }\n\n    if (params.freeModeMomentum) {\n      if (data.velocities.length > 1) {\n        var lastMoveEvent = data.velocities.pop();\n        var velocityEvent = data.velocities.pop();\n        var distance = lastMoveEvent.position - velocityEvent.position;\n        var time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n\n        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {\n          swiper.velocity = 0;\n        } // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n\n\n        if (time > 150 || (0, _utils.now)() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n\n      swiper.velocity *= params.freeModeMomentumVelocityRatio;\n      data.velocities.length = 0;\n      var momentumDuration = 1000 * params.freeModeMomentumRatio;\n      var momentumDistance = swiper.velocity * momentumDuration;\n      var newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n      var doBounce = false;\n      var afterBouncePosition;\n      var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;\n      var needsLoopFix;\n\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeModeSticky) {\n        var nextSlide;\n\n        for (var j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n\n        newPosition = -newPosition;\n      }\n\n      if (needsLoopFix) {\n        swiper.once('transitionEnd', function () {\n          swiper.loopFix();\n        });\n      } // Fix duration\n\n\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n\n        if (params.freeModeSticky) {\n          // If freeModeSticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeModeSticky) {\n        swiper.slideToClosest();\n        return;\n      }\n\n      if (params.freeModeMomentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        $wrapperEl.transitionEnd(function () {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          swiper.emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          setTimeout(function () {\n            swiper.setTranslate(afterBouncePosition);\n            $wrapperEl.transitionEnd(function () {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n\n        if (!swiper.animating) {\n          swiper.animating = true;\n          $wrapperEl.transitionEnd(function () {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.emit('_freeModeNoMomentumRelease');\n        swiper.updateProgress(newPosition);\n      }\n\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeModeSticky) {\n      swiper.slideToClosest();\n      return;\n    } else if (params.freeMode) {\n      swiper.emit('_freeModeNoMomentumRelease');\n    }\n\n    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n\n    return;\n  } // Find current slide\n\n\n  var stopIndex = 0;\n  var groupSize = swiper.slidesSizesGrid[0];\n\n  for (var i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n    var _increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\n    if (typeof slidesGrid[i + _increment] !== 'undefined') {\n      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + _increment]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + _increment] - slidesGrid[i];\n      }\n    } else if (currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  } // Find current slide size\n\n\n  var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n  var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\n  if (timeDiff > params.longSwipesMs) {\n    // Long touches\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (swiper.swipeDirection === 'next') {\n      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);\n    }\n\n    if (swiper.swipeDirection === 'prev') {\n      if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);\n    }\n  } else {\n    // Short swipes\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n\n    if (!isNavButtonTarget) {\n      if (swiper.swipeDirection === 'next') {\n        swiper.slideTo(stopIndex + increment);\n      }\n\n      if (swiper.swipeDirection === 'prev') {\n        swiper.slideTo(stopIndex);\n      }\n    } else if (e.target === swiper.navigation.nextEl) {\n      swiper.slideTo(stopIndex + increment);\n    } else {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}"]},"metadata":{},"sourceType":"script"}